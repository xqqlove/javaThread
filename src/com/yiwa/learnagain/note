//https://blog.csdn.net/wanliguodu/article/details/81005560
//https://blog.csdn.net/wanliguodu/article/details/81005560
https://blog.csdn.net/ns_code/article/details/17539599
我们将synchronized的基本规则总结为下面3条，并通过实例对它们进行说明。
第一条:当一个线程访问某对象的synchronized方法或者synchronized代码块时，其他线程对该对象的该synchronized方法或者synchronized代码块的访问将被阻塞。
第二条:当一个线程访问某对象的synchronized方法或者synchronized代码块时，其他线程仍然可以访问该对象的非同步代码块。
第三条:当一个线程访问某对象的synchronized方法或者synchronized代码块时，其他线程对该对象的其他的synchronized方法或者synchronized代码块的访问将被阻塞。
https://blog.csdn.net/wanliguodu/article/details/81071562

wait()的作用是让[[当前线程]]由“运行状态”进入到“等待（阻塞）”的同时，也会释放同步锁,而yield()的作用是让步，它也是让当前线程离开“运行状态”。区别是：
（1）wait()是让线程由“运行状态”进入到“等待（阻塞）状态”，而yield()是让线程由“运行状态”进入到“就绪状态”。
（2）wait()是会让线程释放它所持有的对象的同步锁，而yield()方法不会释放对象的同步锁

wait()的作用是让当前的线程由“运行状态”进入到“等待（阻塞）状态”的同时，也会释放同步锁。
但是sleep()的作用是让当前线程由“运行状态”进入到“休眠（阻塞）”状态。wait()会释放对象的同步锁，
而sleep()则不会释放锁。

一.同步代码块
synchronized(同步监视器){
  //需要被同步的代码
}
说明：操作共享数据的代码 即为需要同步的代码
      共享数据 ：多个线程共同操作的变量
      同步监视器，俗称 锁。任何一个类的对象都可以充当锁。
      要求：多个线程必须公用同一把锁

二.同步方法
    如果操作共享数据的代码完整的声明在一个方法中，将此方法声明为同步的
    1.同步方法任然涉及同步监视器 ，只是不需要显示的声明
    2.非静态同步方法，同步监视器是：this
    3.静态的同步方法，同步监视器是：当前类本身

死锁问题：不同线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步
      资源，形成了线程死锁

synchronized 和lock的异同
  synchronized 机制在执行完相应的同步代码块以后，自动释放同步监视器
  Lock需要手动的启动同步lock() ,同时结束同步也需要手动实现unlock()




